package com.cylande.unitedretail.batch.business.module;

import com.cylande.unitedretail.batch.business.module.common.QueryDBSelectManagerModule;
import com.cylande.unitedretail.batch.exception.BatchErrorDetail;
import com.cylande.unitedretail.common.tools.StringManager;
import com.cylande.unitedretail.framework.business.exception.FetchException;
import com.cylande.unitedretail.framework.business.jbo.BusinessJboException;
import com.cylande.unitedretail.framework.business.jbo.server.ApplicationModuleImpl;
import com.cylande.unitedretail.framework.business.jbo.server.db.DatabaseProductDetector;
import com.cylande.unitedretail.framework.business.jbo.server.db.EnumDatabaseProduct;
import com.cylande.unitedretail.framework.exception.FrameworkErrorDetail;
import com.cylande.unitedretail.message.common.context.ContextType;
import com.cylande.unitedretail.message.common.queryselect.AnalyzeCostQueryResultType;
import com.cylande.unitedretail.message.common.queryselect.AnalyzeCostQueryScenarioType;
import com.cylande.unitedretail.message.common.queryselect.AnalyzeCostQueryType;
import com.cylande.unitedretail.message.common.queryselect.QueryResultLineType;
import com.cylande.unitedretail.message.common.queryselect.QueryResultType;
import com.cylande.unitedretail.message.common.queryselect.QuerySelectScenarioType;
import com.cylande.unitedretail.message.common.queryselect.QuerySelectType;

import java.lang.reflect.Method;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.UUID;

import oracle.jbo.server.DBTransaction;
import org.apache.log4j.Logger;

// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------

/**
 * Module de gestion du service d'extraction de données directement depuis la BDD à partir d'une requête SQL
 */
public class QueryDBSelectManagerModuleImpl extends ApplicationModuleImpl implements QueryDBSelectManagerModule
{
  /**
   * Logger du module QueryDBSelectManagerModuleImpl
   */
  private static final Logger LOG = Logger.getLogger("SERVICE_QUERY_DB_SELECT");
  /**
   * Liste des mots clé interdits dans une requête
   */
  private static String[] NOT_ALLOWED_KEYWORD = {" ALTER ", " INSERT ", " DELETE ", " DROP ", " UPDATE ", " REVOKE "};
  /**
   * Nombre maximum de colonnes exportées
   */
  private static int NB_MAX_COLUMN = 200;
  /**
   * Mémorise le querySelect pour le traitement par paquets
   */
  private String _querySelectChecksum = null;
  /**
   * Object qui va contenir les metadata de la requête
   */
  private ResultSetMetaData _querySelectMetaData = null;
  /**
   * Permet de savoir si tous les enregitrements ont été parcourus
   */
  private boolean _fetchIsDone = false;
  /**
   * Objet qui permet d'exécuter le requête
   */
  private PreparedStatement _preparedStatement = null;
  /**
   * Objet qui contient le résultat de l'exécution de la requête par le PreparedStatement
   */
  private ResultSet _resultSet = null;
  /**
   * Permet de connaitre l'indice de la dernière ligne exportée par le traitement
   * Comparée au resultSet.getRow(), cela permet de savoir si on peut tenter de passer à la ligne suivante dans isDone();
   */
  private int _lastRowDone = -1;
  /**
   * Formateur décimal utilisé par défaut (celui du système)
   */
  private final DecimalFormat _localDecimalFormat = new DecimalFormat();
  /**
   * Stocke le séparateur decimal local
   */
  private String _localDecimalSeparator;
  /**
   * Stocke le nombre de colonnes du flux de sortie
   */
  private int _nbMaxCol = 0;
  /**
   * Stocke le date format de la query (précisé dans l'appel de service)
   */
  private SimpleDateFormat _queryDateFormat = null;
  /**
   * Stocke le separateur decimal pour la requête (précisé dans l'appel de service)
   */
  private String _queryDecimalSeparator;
  /**
   * Stocke le carractère d'encadrement des chaines de carractères
   */
  private String _quotedStringCar = null;
  /**
   * Stocke un id unique pour le calcul du cout de la requête
   */
  private String _statementId;
  /**
   * Coût max par defaut que ne sera de toute façon pas dépassé
   */
  private int _defaultCostMax = 1000;
  /**
   * Stocke une constante correspondant à un double _quotedStringCar
   */
  private String _doubleQuotedStringCar = null;

  /**
   * This is the default constructor (do not remove)
   */
  public QueryDBSelectManagerModuleImpl()
  {
    //Constructor
  }

  /**
   * Sample main for debugging Business Components code using the tester.
   * @param args arguements de la ligne de commande
   */
  public static void main(String[] args)
  {
    launchTester("com.cylande.unitedretail.batch.business.module", /* package name */
            "QueryDBSelectManagerModuleLocal" /* Configuration Name */);
  }

  /**
   * Execution de la requête
   * @param pQuerySelect la requête à exécuter sur la base
   * @param pScenario    le scenario
   * @param pContext     le context
   * @return QueryResultType
   */
  public QueryResultType querySelect(QuerySelectType pQuerySelect, QuerySelectScenarioType pScenario, ContextType pContext)
  {
    QueryResultType result = null;
    getChrono().start();
    try
    {
      //Contrôles de base
      if (authorizedDbProduct() && inputsValidExecuteQuery(pQuerySelect))
      {
        //règles métier
        if (authorizedQuery(pQuerySelect.getQryStatement()) && controlCostQuery(pQuerySelect, pScenario))
        {
          result = executeQueryInternal(pQuerySelect, pScenario, pContext);
        }
      }
    }
    finally
    {
      getChrono().stop(this);
    }
    return result;
  }

  /**
   * Analyse du coup d'execution de la requête
   * @param pAnalyseCostQuery la requête à analyser sur la base
   * @param pScenario         le scenario
   * @param pContext          le context
   * @return AnalyzeCostQueryResultType
   */
  public AnalyzeCostQueryResultType analyzeCostQuery(AnalyzeCostQueryType pAnalyseCostQuery, AnalyzeCostQueryScenarioType pScenario, ContextType pContext)
  {
    AnalyzeCostQueryResultType result = null;
    getChrono().start();
    try
    {
      //Contrôles de base
      if (authorizedDbProduct() && inputsValidAnalyzeCostQuery(pAnalyseCostQuery))
      {
        //règles métier
        if (authorizedQuery(pAnalyseCostQuery.getQryStatement()))
        {
          result = analyzeCostQueryInternal(pAnalyseCostQuery, pScenario);
        }
      }
    }
    finally
    {
      getChrono().stop(this);
    }
    return result;
  }

  /**
   * Ajoute une ligne au jeu d'enregitrements de sortie
   * @param pQueryResult     Conteneur destinataire des enregistrements
   * @param pQueryResultLine Line de donnée à ajouter
   */
  private void addResultLineToQueryResult(QueryResultType pQueryResult, QueryResultLineType pQueryResultLine)
  {
    if (pQueryResultLine != null && pQueryResult != null)
    {
      pQueryResult.getValues().add(pQueryResultLine);
    }
  }

  /**
   * Permet de lancer l'analyse du coup de la requête avant execution
   * @param pAnalyseCostQuery Requête qui doit être exécutée et qu'il faut donc analyser
   * @param pScenario         le scenario
   * @return AnalyzeCostQueryResultType contient le résultat de l'analyse de coût
   */
  private AnalyzeCostQueryResultType analyzeCostQueryInternal(AnalyzeCostQueryType pAnalyseCostQuery, AnalyzeCostQueryScenarioType pScenario)
  {
    AnalyzeCostQueryResultType result = new AnalyzeCostQueryResultType();
    result.setCost(-1);
    //Génère un statement Id
    initStatementId();
    //Execution du plan d'exécution
    executeExplainPlan(pAnalyseCostQuery);
    try
    {
      //Récupération du coût dans la table système qui stocke les plan d'exécution
      result.setCost(readExplainPlanCost());
    }
    finally
    {
      //Supprime les informations du plan d'éxécution calculé
      clearExplainPlanData();
    }
    return result;
  }

  /**
   * Permet de savoir si le service est implémenté pour le type de BDD en cours
   * @return vrai si les service est implémenté pour le BDD, sinon log et exception
   */
  private boolean authorizedDbProduct()
  {
    EnumDatabaseProduct dbProduct = DatabaseProductDetector.getInstance().getDatabaseProduct();
    if (dbProduct != null && dbProduct != EnumDatabaseProduct.Oracle)
    {
      LOG.error("Service non implémenté pour ce type de base de données.");
      throw new BusinessJboException(BatchErrorDetail.QUERY_SQL_NOT_IMPLEMENTED_YET);
    }
    return true;
  }

  /**
   * permet de savoir si la requête passée en paramètre est syntaxiquement autorisée
   * @param pQuery requête à executer
   * @return retourne true si la requête est autorisée, faux sinon
   */
  private boolean authorizedQuery(String pQuery)
  {
    String query = " " + pQuery.trim().toUpperCase() + " ";
    //La requête doit commencer par SELECT
    if (!query.startsWith(" SELECT "))
    {
      throw new BusinessJboException(BatchErrorDetail.QUERY_SQL_NOT_READONLY_ERROR);
    }
    //La requête ne doit pas contenir certains mots clé (pas de mise à jour...)
    for (String keyWord : NOT_ALLOWED_KEYWORD)
    {
      if (query.contains(keyWord))
      {
        throw new BusinessJboException(BatchErrorDetail.QUERY_SQL_NOT_READONLY_ERROR);
      }
    }
    return true;
  }

  /**
   * Contrôle si le pQuerySelect utilisé pour la requête est idendique au précédent
   * @param pQuerySelect : Requête qui doit être exécutée
   * @return boolean
   */
  private boolean checkQuerySelectChecksum(QuerySelectType pQuerySelect)
  {
    if (_querySelectChecksum == null)
    {
      _querySelectChecksum = getChecksum(pQuerySelect.toCacheKey());
    }
    else
    {
      String newChecksum = getChecksum(pQuerySelect.toCacheKey());
      if (!newChecksum.equals(_querySelectChecksum))
      {
        return false;
      }
    }
    return true;
  }

  /**
   * Nettoyage de la table PLAN_TABLE
   */
  private void clearExplainPlanData()
  {
    getChrono().start();
    try
    {
      String query = "DELETE FROM Plan_Table WHERE Statement_Id='" + _statementId + "'";
      PreparedStatement ps = this.getDBTransaction().createPreparedStatement(query, DBTransaction.DEFAULT);
      ps.execute();
      ps.close();
    }
    catch (SQLException exception)
    {
      LOG.error("Erreur lors du nettoyage de PLAN_TABLE");
      throw new BusinessJboException(BatchErrorDetail.QUERY_SQL_ERROR_COST_ANALYZE);
    }
    finally
    {
      getChrono().stop(this);
    }
  }

  /**
   * Nettoie le PreparedStatement
   */
  private void clearStatementSet()
  {
    try
    {
      _resultSet.close();
      _preparedStatement.close();
    }
    catch (SQLException e)
    {
      LOG.error(e);
    }
    finally
    {
      _resultSet = null;
      _querySelectMetaData = null;
      _preparedStatement = null;
    }
  }

  /**
   * Constitue une ligne d'enregistrement avec les noms de colonnes
   * @param pQuerySelect Requête qui doit être exécutée
   * @return QueryResultLineType enregistrement au format QueryResultLineType
   */
  private QueryResultLineType computeHeaderLine(QuerySelectType pQuerySelect)
  {
    QueryResultLineType resultLine = null;
    try
    {
      resultLine = new QueryResultLineType();
      String fieldName;
      Method setField = null;
      for (int col = 1; col <= _nbMaxCol; col++)
      {
        fieldName = "setValueField" + (col);
        setField = resultLine.getClass().getMethod(fieldName, String.class);
        setField.invoke(resultLine, _querySelectMetaData.getColumnName(col));
      }
    }
    catch (Exception e)
    {
      throw new BusinessJboException(BatchErrorDetail.QUERY_SQL_EXECUTE_ERROR);
    }
    return resultLine;
  }

  /**
   * Retourne un enregistrement de la requête avec les champs correctement formatés
   * @param pQuerySelect Requête qui doit être exécutée
   * @return enregistrement au format QueryResultLineType
   */
  private QueryResultLineType computeQueryResultLine(QuerySelectType pQuerySelect)
  {
    getChrono().start();
    QueryResultLineType resultLine = null;
    try
    {
      resultLine = new QueryResultLineType();
      String fieldName;
      Method setField = null;
      for (int col = 1; col <= _nbMaxCol; col++)
      {
        fieldName = "setValueField" + (col);
        setField = resultLine.getClass().getMethod(fieldName, String.class);
        setField.invoke(resultLine, getFieldValue(pQuerySelect, col));
      }
    }
    catch (Exception e)
    {
      throw new BusinessJboException(BatchErrorDetail.QUERY_SQL_EXECUTE_ERROR);
    }
    finally
    {
      getChrono().stop(this);
    }
    return resultLine;
  }

  /**
   * Contrôle le coût de la requête avant execution (si le scenario de demande)
   * @param pQuerySelect requête à executer
   * @param pScenario    le scenario
   * @return vrai si le coût de la requête est acceptable
   */
  private boolean controlCostQuery(QuerySelectType pQuerySelect, QuerySelectScenarioType pScenario)
  {
    if (isFirstFind())
    {
      AnalyzeCostQueryType analyseCostQuery = new AnalyzeCostQueryType();
      analyseCostQuery.setQryStatement(pQuerySelect.getQryStatement());
      AnalyzeCostQueryScenarioType analyseCostQueryScenario = new AnalyzeCostQueryScenarioType();
      AnalyzeCostQueryResultType analyzeCostQueryResult = analyzeCostQueryInternal(analyseCostQuery, analyseCostQueryScenario);
      if (analyzeCostQueryResult.getCost().intValue() < 0)
      {
        //Cas qui ne devrait normalement pas se produire...
        LOG.error("La requête n’a pu être exécutée car son coût n'a pas pu être obtenu.");
        throw new BusinessJboException(BatchErrorDetail.QUERY_SQL_ERROR_COST_ANALYZE);
      }
      else if (analyzeCostQueryResult.getCost().intValue() > getCostMaxInternal(pScenario))
      {
        LOG.error("La requête n’a pu être exécutée car son coût est trop élevé ou sa complexité est trop importante.(" + String.valueOf(analyzeCostQueryResult.getCost().intValue()) + ")");
        throw new BusinessJboException((BatchErrorDetail.QUERY_SQL_HIGHER_COST));
      }
    }
    return true;
  }

  /**
   * Calcul du plan d'éxution de la requête
   * Cette méthode execute une requête sur la serveur SQL.
   * Cette requête ne retourne rien, le résultat de l'exécution est stocké dans une table système
   * le coût sera récupéré par la méthode readExplainPlanCost
   * @param pAnalyzeCostQuery Requête à analyser
   */
  private void executeExplainPlan(AnalyzeCostQueryType pAnalyzeCostQuery)
  {
    getChrono().start();
    try
    {
      //Contitution de la requête qui ca calculer le coût
      StringBuilder query = new StringBuilder();
      query.append("EXPLAIN PLAN SET Statement_id = '" + _statementId + "' FOR ");
      query.append(pAnalyzeCostQuery.getQryStatement());
      PreparedStatement  ps = this.getDBTransaction().createPreparedStatement(query.toString(), DBTransaction.DEFAULT);
      //Exécution du calcul du coût
      ps.execute();
      //Fermeture du preparedStatement le plan d'exécution et donc le coût on été stockés dans la table PLAN_TABLE
      ps.close();
    }
    catch (SQLException exception)
    {
      LOG.error("Erreur lors de l'appel à EXPLAIN PLAN. (" + exception.getMessage() + ")");
      throw new BusinessJboException(BatchErrorDetail.QUERY_SQL_ERROR_COST_ANALYZE);
    }
    finally
    {
      getChrono().stop(this);
    }
  }

  /**
   * Execute la requête aprés avoir contrôlé les règles metier et retourne les enregistrements
   * @param pQuerySelect Requête qui doit être exécutée
   * @param pContext     Contexte
   * @return Jeu d'enregistrements au format QueryResultType
   */
  private QueryResultType executeQueryInternal(QuerySelectType pQuerySelect, QuerySelectScenarioType pScenario, ContextType pContext)
  {
    getChrono().start();
    QueryResultType result = null;
    boolean firstLine = false;
    try
    {
      if (isDone())
      {
        return null;
      }
      if (isFirstFind())
      {
        saveQuerySelectChecksum(pQuerySelect);
        //Recupère le séparateur décimal du système
        DecimalFormatSymbols decimalSymbols = _localDecimalFormat.getDecimalFormatSymbols();
        _localDecimalSeparator = new StringBuilder().append(decimalSymbols.getDecimalSeparator()).toString();
        //recupère le séparateur décimal de l'appel de service, si non précisé on prend le local
        if (!StringManager.isEmpty(pQuerySelect.getDecimalSeparator()))
        {
          _queryDecimalSeparator = pQuerySelect.getDecimalSeparator();
        }
        else
        {
          _queryDecimalSeparator = _localDecimalSeparator;
        }
        //Recupère le dateFormat de l'appel de service
        if (!StringManager.isEmpty(pQuerySelect.getDateFormat()))
        {
          _queryDateFormat = new SimpleDateFormat(pQuerySelect.getDateFormat());
        }
        //Recupère de carractère d'encadrement des chaines
        _quotedStringCar = pQuerySelect.getQuotedStringCar();
        //initialise le double _quotedStringCar;
        if (_quotedStringCar != null)
        {
          _doubleQuotedStringCar = _quotedStringCar + _quotedStringCar;
        }
        //Trace la requête dans le le Log4J
        LOG.error("Requête exécutée: " + pQuerySelect.getQryStatement());
        _preparedStatement = this.getDBTransaction().createPreparedStatement(pQuerySelect.getQryStatement(), DBTransaction.DEFAULT);
        if (_preparedStatement != null)
        {
          _querySelectMetaData = _preparedStatement.getMetaData();
          //Contrôle si la requête ne retourne pas plus de 30 colonnes
          if (pScenario != null && Boolean.TRUE.equals(pScenario.getExceptionOnMaxField()))
          {
            if (_querySelectMetaData != null && _querySelectMetaData.getColumnCount() > NB_MAX_COLUMN)
            {
              throw new BusinessJboException(BatchErrorDetail.QUERY_SQL_MAX_COLUMN_ERROR);
            }
          }
          //Execute la requête
          _resultSet = _preparedStatement.executeQuery();
          firstLine = true;
        }
      }
      else if (!checkQuerySelectChecksum(pQuerySelect))
      {
        throw new FetchException(FrameworkErrorDetail.FETCH_CRITERIA_DIFF);
      }
      result = new QueryResultType();
      if (_querySelectMetaData != null)
      {
        QueryResultLineType queryResultLine = null;
        if (firstLine)
        {
          //Stock le nombre de colonnes du bean
          _nbMaxCol = _querySelectMetaData.getColumnCount() > NB_MAX_COLUMN ? NB_MAX_COLUMN : _querySelectMetaData.getColumnCount();
          //Ajoute les entètes de colonnes au jeu de données
          queryResultLine = computeHeaderLine(pQuerySelect);
          addResultLineToQueryResult(result, queryResultLine);
        }
        if (_resultSet != null)
        {
          for (int i = 0; i < pContext.getRangeSize() && !isDone(); i++)
          {
            //Ajoute les enregistrements
            queryResultLine = computeQueryResultLine(pQuerySelect);
            addResultLineToQueryResult(result, queryResultLine);
            //on mémorise l'indice de la dernière ligne traitée (voir isDone())
            _lastRowDone = _resultSet.getRow();
          }
        }
      }
    }
    catch (SQLException exception)
    {
      throw new BusinessJboException(BatchErrorDetail.QUERY_SQL_EXECUTE_ERROR);
    }
    finally
    {
      getChrono().stop(this);
    }
    return result;
  }

  /**
   * Retourne le Coût Max le plus défavorable entre le coût par défaut et celui de scénario
   * @param pScenario le scénario
   * @return le coût
   */
  private int getCostMaxInternal(QuerySelectScenarioType pScenario)
  {
    int cost = _defaultCostMax;
    if (pScenario != null && pScenario.getCostMax() != null && pScenario.getCostMax().intValue() > 0)
    {
      if (pScenario.getCostMax().intValue() < _defaultCostMax)
      {
        cost = pScenario.getCostMax().intValue();
      }
      LOG.error("Un coup d'exécution maximal de " + String.valueOf(cost) + " sera appliqué.");
    }
    else
    {
      LOG.error("Un coup d'exécution maximal de " + String.valueOf(cost) + " sera appliqué par défaut.");
    }
    return cost;
  }

  /**
   * Permet de retourner la valeur d'une colonne de la requête au bon format
   * @param pQuerySelect Requête qui doit être exécutée
   * @param pFieldIndex  Numero de la colonne a traiter
   * @return Valeur sous forme d'une chaine
   * @throws SQLException Exception de type SQL
   */
  private String getFieldValue(QuerySelectType pQuerySelect, int pFieldIndex) throws SQLException
  {
    String result = null;
    if (_resultSet.getString(pFieldIndex) != null)
    {
      if (_quotedStringCar != null && _querySelectMetaData.getColumnTypeName(pFieldIndex).toUpperCase().contains("CHAR"))
      {
        StringBuilder value = new StringBuilder();
        value.append(_quotedStringCar);
        value.append(_resultSet.getString(pFieldIndex).replaceAll(_quotedStringCar, _doubleQuotedStringCar));
        value.append(_quotedStringCar);
        result = value.toString();
      }
      else if (_querySelectMetaData.getColumnTypeName(pFieldIndex).equalsIgnoreCase("NUMBER"))
      {
        double value = _resultSet.getDouble(pFieldIndex);
        if (!_resultSet.wasNull())
        {
          //On formate d'abord au format local, comme ça on connait le séparateur décimal de départ
          result = _localDecimalFormat.format(value);
          //Si séparateur demandé différent on le remplace
          if (_localDecimalSeparator.compareToIgnoreCase(_queryDecimalSeparator) != 0)
          {
            result = result.replace(_localDecimalSeparator, _queryDecimalSeparator);
          }
        }
      }
      else if (_queryDateFormat != null && _querySelectMetaData.getColumnTypeName(pFieldIndex).equalsIgnoreCase("TIMESTAMP"))
      {
        Date value = _resultSet.getDate(pFieldIndex);
        result = _resultSet.wasNull() ? null : _queryDateFormat.format(value);
      }
      else
      {
        result = _resultSet.getString(pFieldIndex);
      }
    }
    return result;
  }


  /**
   * Permet de générer un statementId qui servira d'identifiant unique pour le calcul du coût de la requête
   */
  private void initStatementId()
  {
    _statementId = UUID.randomUUID().toString().replaceAll("-", "").substring(0, 30);
  }

  /**
   * Permet de savoir si l'appel de service analyzeCostQuery est correctement formulé
   * @param pAnalyseCostQuery Requête qui doit être analysée
   * @return vrai si correctement formulé, exception sinon
   */
  private boolean inputsValidAnalyzeCostQuery(AnalyzeCostQueryType pAnalyseCostQuery)
  {
    getChrono().start();
    try
    {
      if (pAnalyseCostQuery == null)
      {
        LOG.error("Objet analyseCostQuery absent des paramètres d'appel");
        throw new BusinessJboException(BatchErrorDetail.QUERY_SQL_INVALID_PARAMS);
      }
      else if (pAnalyseCostQuery.getQryStatement() == null)
      {
        LOG.error("Propriété qryStatement absente des paramètres d'appel");
        throw new BusinessJboException(BatchErrorDetail.QUERY_SQL_INVALID_PARAMS);
      }
      else if (StringManager.isEmpty(pAnalyseCostQuery.getQryStatement().trim()))
      {
        LOG.error("Requête SQL à analyser absente des paramètres d'appel");
        throw new BusinessJboException(BatchErrorDetail.QUERY_SQL_INVALID_PARAMS);
      }
    }
    finally
    {
      getChrono().stop(this);
    }
    return true;
  }

  /**
   * Permet de savoir si l'appel de service ExecuteQuery est correctement formulé
   * @param pQuerySelect Requête qui doit être exécutée
   * @return vrai si correctement formulé, exception sinon
   */
  private boolean inputsValidExecuteQuery(QuerySelectType pQuerySelect)
  {
    getChrono().start();
    try
    {
      if (pQuerySelect == null)
      {
        LOG.error("Objet querySelect absent des paramètres d'appel");
        throw new BusinessJboException(BatchErrorDetail.QUERY_SQL_INVALID_PARAMS);
      }
      else if (pQuerySelect.getQryStatement() == null)
      {
        LOG.error("Propriété qryStatement absente des paramètres d'appel");
        throw new BusinessJboException(BatchErrorDetail.QUERY_SQL_INVALID_PARAMS);
      }
      else if (StringManager.isEmpty(pQuerySelect.getQryStatement().trim()))
      {
        LOG.error("Requête SQL à exécuter absente des paramètres d'appel");
        throw new BusinessJboException(BatchErrorDetail.QUERY_SQL_INVALID_PARAMS);
      }
    }
    finally
    {
      getChrono().stop(this);
    }
    return true;
  }

  /**
   * Indique si la lecture des enregitrements est complétement terminée
   * @return boolean
   */
  private boolean isDone() throws SQLException
  {
    if (!_fetchIsDone)
    {
      if (_resultSet != null && (_lastRowDone == -1 || _lastRowDone == _resultSet.getRow()) && !_resultSet.next())
      {
        _fetchIsDone = true;
      }
      if (_fetchIsDone)
      {
        clearStatementSet();
      }
    }
    return _fetchIsDone;
  }

  /**
   * Indique si c'est la première recherche
   * @return boolean
   */
  private boolean isFirstFind()
  {
    return (_querySelectChecksum == null);
  }

  /**
   * Lit la valeur du coût de la requête dans la table PLAN_TABLE
   * qui a été généré par la méthode executeExplainPlan
   * @return le coût
   */
  private int readExplainPlanCost()
  {
    int result = -1;
    getChrono().start();
    try
    {
      StringBuilder query = new StringBuilder();
      query.append("SELECT p1.Cost ");
      query.append("FROM PLAN_TABLE p1 ");
      query.append("WHERE p1.Statement_id = '" + _statementId + "' ");
      query.append("AND p1.ID = 0 ");
      query.append("AND p1.TimeStamp = (SELECT MAX(p2.TimeStamp) ");
      query.append("                    FROM Plan_Table p2 ");
      query.append("                    WHERE p2.Statement_id = '" + _statementId + "' ");
      query.append("                    AND p2.ID = 0) ");
      PreparedStatement ps = this.getDBTransaction().createPreparedStatement(query.toString(), DBTransaction.DEFAULT);
      ResultSet rs = ps.executeQuery();
      if (rs.next())
      {
        result = rs.getInt(1);
      }
      rs.close();
      ps.close();
    }
    catch (SQLException exception)
    {
      LOG.error("Erreur lors de la lecture du coût dans la table PLAN_TABLE.");
      throw new BusinessJboException(BatchErrorDetail.QUERY_SQL_ERROR_COST_ANALYZE);
    }
    finally
    {
      getChrono().stop(this);
    }
    return result;
  }

  /**
   * Mémorise la signature du querySelect
   * @param pQuerySelect : Requête qui doit être exécutée
   */
  private void saveQuerySelectChecksum(QuerySelectType pQuerySelect)
  {
    _querySelectChecksum = getChecksum(pQuerySelect.toCacheKey());
  }
}
