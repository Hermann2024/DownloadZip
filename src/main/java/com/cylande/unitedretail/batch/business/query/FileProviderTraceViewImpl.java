package com.cylande.unitedretail.batch.business.query;

import java.util.Iterator;

import oracle.jbo.Key;
import oracle.jbo.Row;

import org.apache.log4j.Logger;

import com.cylande.unitedretail.batch.business.entity.FileProviderTraceImpl;
import com.cylande.unitedretail.batch.business.query.common.FileProviderTraceView;
import com.cylande.unitedretail.batch.business.query.common.FileProviderTraceViewRow;
import com.cylande.unitedretail.common.transformer.CriteriaTransformer;
import com.cylande.unitedretail.framework.business.BusinessException;
import com.cylande.unitedretail.framework.business.jbo.server.ViewObjectImpl;
import com.cylande.unitedretail.message.batch.FileProviderTraceCriteriaListType;
import com.cylande.unitedretail.message.batch.FileProviderTraceCriteriaType;
import com.cylande.unitedretail.message.batch.FileProviderTraceKeyType;
import com.cylande.unitedretail.message.batch.FilterDomainListType;
import com.cylande.unitedretail.message.batch.FilterDomainType;
import com.cylande.unitedretail.message.common.criteria.CriteriaStringType;
import com.cylande.unitedretail.message.sequence.SequenceKeyType;
// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------
public class FileProviderTraceViewImpl extends ViewObjectImpl implements FileProviderTraceView
{
  /**
   * Logger
   */
  private static final Logger LOGGER = Logger.getLogger(FileProviderTraceViewImpl.class);

  /**This is the default constructor (do not remove)
   */
  public FileProviderTraceViewImpl()
  {
  }

  /**
   * getRow
   * @param pKey
   * @return TaskRunViewRow
   */
  public FileProviderTraceViewRow getRow(FileProviderTraceKeyType pKey)
  {
    FileProviderTraceViewRow result = null;
    if (pKey != null)
    {
      if (pKey.getId() != null)
      {
        return getRowById(pKey.getId());
      }
      // Mise en commentaire de la méthode.
      // Pour le moment, on limite la recherche par clé à l'identifiant interne.
      // A voir s'il faut mettre en place une unicité basée sur d'autres
      // colonnes pour faire un getRowByBean dans le cas où l'id n'est pas
      // renseigné. La méthode getRowByTaskId telle qu'elle est actuellement
      // ne fonctionne pas et fait un FULL ACCESS sur la table
      // FILE_PROVIDER_TRACE.
      //return getRowByTaskId(pKey.getTaskCode(), pKey.getTaskId(), pKey.getSite());
    }
    return result;
  }

  private FileProviderTraceViewRow getRowById(Integer pId)
  {
    FileProviderTraceViewRow result = null;
    Key key = FileProviderTraceImpl.createPrimaryKey(new com.cylande.unitedretail.framework.business.jbo.domain.common.Integer(pId));
    Row[] rows = findByKey(key, -1);
    if (rows.length == 1)
    {
      result = (FileProviderTraceViewRow)rows[0];
    }
    else
    {
      LOGGER.warn("getRowById");
    }
    return result;
  }
  /**
   * getRowByTaskId
   * @param pTaskCode
   * @param pTaskId
   * @param pSite
   * @return TaskRunViewRow
   */
  /*public FileProviderTraceViewRow getRowByTaskId(String pTaskCode, Integer pTaskId, SiteKeyType pSite)
  {
    FileProviderTraceViewRow result = null;
    if (pTaskCode != null && pTaskId != null)
    {
      AttributeList myList = new NameValuePairs();
      myList.setAttribute("TaskCode", pTaskCode);
      myList.setAttribute("TaskId", pTaskId);
      if (pSite != null && pSite.getCode() != null)
      {
        myList.setAttribute("SiteCode", pSite.getCode());
      }
      Key myKey = createKey(myList);
      Row[] myArray = findByKey(myKey, -1);
      int recordCount = myArray.length;
      if (recordCount == 1)
      {
        result = (FileProviderTraceViewRow)myArray[0];
      }
      else if (recordCount > 1)
      {
        int i = 0;
        FileProviderTraceViewRow theRow;
        String[] names;
        Object[] values;
        while (i < recordCount)
        {
          theRow = (FileProviderTraceViewRow)myArray[i];
          names = theRow.getAttributeNames();
          values = theRow.getAttributeValues();
          int j = 0;
          while (j < theRow.getAttributeCount())
          {
            if (names[j].equals("TaskCode") && values[j].equals(pTaskCode))
            {
              result = theRow;
              break;
            }
            j++;
          }
          if (result != null)
          {
            break;
          }
          i++;
        }
        if (pSite != null && pSite.getCode() != null)
        {
          _log.info("getRowByTaskId : " + pTaskCode + "/" + pTaskId + "/" + pSite.getCode() + " : " + recordCount);
        }
        else
        {
          _log.info("getRowByTaskId : " + pTaskCode + "/" + pTaskId + " : " + recordCount);
        }
      }
      else
      {
        _log.info("getRowByTaskId : " + pTaskCode + "/" + pTaskId + "/" + pSite.getCode() + " : " + recordCount);
      }
    }
    else
    {
      _log.warn("getRowByTaskId");
    }
    return result;
  }*/

  /**
   * findByCriterias
   * @param pCriterias
   */
  public void findByCriterias(FileProviderTraceCriteriaListType pCriterias)
  {
    if (pCriterias != null)
    {
      setWhereClause(null);
      setWhereClauseParams(null);
      CriteriaTransformer criteriaTransformer = CriteriaTransformer.createCriteriaWhereClause(this);
      Iterator<FileProviderTraceCriteriaType> it = pCriterias.getList().iterator();
      while (it.hasNext())
      {
        FileProviderTraceCriteriaType fileProviderTraceCriteria = it.next();
        criteriaTransformer.addElement("TASK_CODE", fileProviderTraceCriteria.getTaskCode());
        criteriaTransformer.addElement("TASK_ID", fileProviderTraceCriteria.getTaskId());
        if (fileProviderTraceCriteria.getDomainList() != null && !fileProviderTraceCriteria.getDomainList().getList().isEmpty())
        {
          //creation d'une liste
          CriteriaStringType domain = createCriteria(fileProviderTraceCriteria.getDomainList());
          criteriaTransformer.addElement("DOMAIN", domain);
        }
        criteriaTransformer.addElement("PROVIDER_NAME", fileProviderTraceCriteria.getProviderName());
        criteriaTransformer.addElement("FILE_PATH", fileProviderTraceCriteria.getFilePath());
        if (fileProviderTraceCriteria.getSite() != null && fileProviderTraceCriteria.getSite().getCode() != null)
        {
          criteriaTransformer.addElement("SITE_CODE", fileProviderTraceCriteria.getSite().getCode());
        }
        criteriaTransformer.closeCurrentCriteria();
      }
      setWhereClause(criteriaTransformer.getWhereClause());
      setWhereClauseParams(criteriaTransformer.getParams());
    }
    executeQuery();
  }

  /**
   * insertRow
   * @param pRow
   */
  public void insertRow(FileProviderTraceViewRow pRow)
  {
    if (pRow.getID() == null || pRow.getID().intValue() == 0)
    {
      SequenceKeyType key = new SequenceKeyType();
      key.setCode(getName());
      try
      {
        insertSequenceId(pRow, new FileProviderTraceSequenceHandler(pRow, key));
      }
      catch (Exception e)
      {
        LOGGER.error(e.getMessage(), e);
        throw new BusinessException(500000, e.getMessage());
      }
    }
    else
    {
      super.insertRow(pRow);
    }
  }

  private CriteriaStringType createCriteria(FilterDomainListType pFilterDomainListType)
  {
    CriteriaStringType domain = new CriteriaStringType();
    for (FilterDomainType filterDomain: pFilterDomainListType.getList())
    {
      domain.getInList().add(filterDomain.getFilterDomain());
    }
    return domain;
  }
}
